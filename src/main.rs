mod vec3;
mod ray;
mod hit;

use vec3::Color;

use std::cell::{RefCell, Ref};
use crate::vec3::{Point, Vec3, Pixel};
use crate::ray::Ray;
use crate::hit::{Sphere, Hittable, HitRecord};
use minpixwin::Screen;

fn main() {
    const ASPECT_RATIO: f32 = 16.0 / 9.0;
    const IMAGE_WIDTH: usize = 800;
    const IMAGE_HEIGHT: usize = (IMAGE_WIDTH as f32 / ASPECT_RATIO) as usize;
    const W: usize = IMAGE_WIDTH;
    const H: usize = IMAGE_HEIGHT;

    let viewport_height = 2.0;
    let viewport_width = ASPECT_RATIO * viewport_height;
    let focal_length = 1.0;

    let origin: Point = Vec3(0.0, 0.0, 0.0);
    let horizontal = Vec3(viewport_width, 0.0, 0.0);
    let vertical = Vec3(0.0, viewport_height, 0.0);
    let lower_left_corner = origin - horizontal / 2.0 - vertical / 2.0 - Vec3(0.0, 0.0, focal_length);

    let hittables: Vec<Box<dyn Hittable>> = vec![
        Box::new(Sphere { radius: 0.75, center: Vec3(-0.8, -0.3, -2.0) }),
        Box::new(Sphere { radius: 0.5, center: Vec3(0.0, 0.0, -1.0) }),
        Box::new(Sphere { radius: 50.0, center: Vec3(0.4, -50.5, -1.1) }),
    ];

    let mut p: Vec<Pixel> = vec![Vec3(0.0, 0.0, 0.0); W * H];

    for j in (0..H).rev() {
        //eprintln!("\rScanlines remaining: {}", j);
        for i in 0..W {
            //p[i+W*j] = Pixel::new((i as f32)/(W as f32), j as f32/H as f32, 0.25);
            let u = (i as f32) / ((IMAGE_WIDTH - 1) as f32);
            let v = (j as f32) / ((IMAGE_HEIGHT - 1) as f32);
            let r = Ray {
                origin: origin,
                direction: lower_left_corner + u * horizontal + v * vertical,
            };
            let mut hitcolor = None;
            hitcolor = ray_color(&r, &hittables);

            p[i + W * j] = hitcolor.unwrap_or_else(|| bg_color(&r));
        }
    }

    let i = Image {
        w: W as u32,
        h: H as u32,
        pixels: p,
    };

    //to render to "file"
    //i.print_ppm();

    Screen::new(W, H, move |buf| {
        //flip buffer upside down to get same result as in the article for less confusion
        let mut flipped = i.pixels.iter().rev();

        //assume 32bit output texture buffer, take 4 bytes from buf and put each of our 24bit Pixel into
        for pixel in buf.chunks_exact_mut(4) {
            let p = flipped.next().unwrap();
            let p = [(p.0 * 255.0) as u8, (p.1 * 255.0) as u8, (p.2 * 255.0) as u8, 255];
            pixel.copy_from_slice(&p);
        };
    });
}

const T_MAX: f32 = 3.0;

///
/// return color of closest hit object along ray, color generated by hit location normal angle
///
fn ray_color(r: &Ray, hittables: &Vec<Box<dyn Hittable>>) -> Option<Color> {
    let mut rec: Option<HitRecord> = None;
    let mut closest_yet = T_MAX;

    for hittable in hittables {
        let hit_rec = hittable.hit(&r, 0.0, closest_yet);

        if hit_rec.is_some() {
            closest_yet = hit_rec.as_ref().unwrap().t;
            rec = hit_rec;
        }
    }
    match rec {
        None => { None }
        Some(rec) => {
            let n = rec.normal + Vec3::newi(1, 1, 1);
            Some(0.5 * n)
        }
    }
}

//blue gradient
fn bg_color(r: &Ray) -> Color {
    let unit_direction = r.direction.unit_vector();
    let len = r.direction.length_squared();
    let t = 0.5 * (unit_direction.y() + 1.0);
    (1.0 - t) * Color::new(1.0, 1.0, 1.0) + t * Color::new(0.5, 0.7, 1.0)
}



struct Image {
    w: u32,
    h: u32,
    pixels: Vec<Pixel>,
}

impl Image {
    /// render as a simple image format, to view result in some image viewer
    fn print_ppm(&self) {
        println!("P3");
        println!("{} {}", self.w, self.h);
        println!("255");
        for row in self.pixels.chunks(self.w as usize).rev() {
            for p in row {
                print!("{} ", p);
            }
            println!();
        }
    }
}
